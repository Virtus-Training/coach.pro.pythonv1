"""
Module d'optimisation de la base de donn√©es pour les performances nutritionnelles
Cr√©e les index appropri√©s pour des recherches sub-200ms
"""

import sqlite3
import time
from typing import List, Dict
from db.database_manager import db_manager


class DatabaseOptimizer:
    """Optimiseur de performance pour la base de donn√©es nutritionnelle"""
    
    def __init__(self):
        self.optimization_history = []
    
    def optimize_full_database(self) -> Dict[str, any]:
        """Optimisation compl√®te de la base de donn√©es"""
        
        start_time = time.time()
        results = {}
        
        print("üöÄ D√©but de l'optimisation de la base de donn√©es...")
        
        # 1. Cr√©ation des index pour les aliments
        results['aliments_indexes'] = self._create_aliments_indexes()
        
        # 2. Cr√©ation des index pour les profils nutritionnels
        results['profils_indexes'] = self._create_profils_indexes()
        
        # 3. Cr√©ation des index pour les plans alimentaires
        results['plans_indexes'] = self._create_plans_indexes()
        
        # 4. Optimisation des index existants
        results['existing_optimization'] = self._optimize_existing_indexes()
        
        # 5. Analyse et statistiques
        results['statistics'] = self._analyze_database_stats()
        
        # 6. Configuration SQLite pour les performances
        results['sqlite_config'] = self._optimize_sqlite_settings()
        
        total_time = time.time() - start_time
        results['total_optimization_time'] = round(total_time, 2)
        
        print(f"‚úÖ Optimisation termin√©e en {results['total_optimization_time']}s")
        
        return results
    
    def _create_aliments_indexes(self) -> Dict[str, bool]:
        """Cr√©e les index optimaux pour la table aliments"""
        
        print("üìä Cr√©ation des index pour la table 'aliments'...")
        
        indexes = {
            # Index de recherche textuelle (TR√àS IMPORTANT pour MyFitnessPal-like search)
            'idx_aliments_nom': 'CREATE INDEX IF NOT EXISTS idx_aliments_nom ON aliments(nom COLLATE NOCASE)',
            'idx_aliments_nom_prefix': 'CREATE INDEX IF NOT EXISTS idx_aliments_nom_prefix ON aliments(substr(nom, 1, 3))',
            
            # Index nutritionnels pour filtres rapides
            'idx_aliments_kcal': 'CREATE INDEX IF NOT EXISTS idx_aliments_kcal ON aliments(kcal_100g)',
            'idx_aliments_proteines': 'CREATE INDEX IF NOT EXISTS idx_aliments_proteines ON aliments(proteines_100g)',
            'idx_aliments_glucides': 'CREATE INDEX IF NOT EXISTS idx_aliments_glucides ON aliments(glucides_100g)',\n            'idx_aliments_lipides': 'CREATE INDEX IF NOT EXISTS idx_aliments_lipides ON aliments(lipides_100g)',\n            'idx_aliments_fibres': 'CREATE INDEX IF NOT EXISTS idx_aliments_fibres ON aliments(fibres_100g)',\n            \n            # Index pour cat√©gorisation et filtres\n            'idx_aliments_categorie': 'CREATE INDEX IF NOT EXISTS idx_aliments_categorie ON aliments(categorie)',\n            'idx_aliments_type_alimentation': 'CREATE INDEX IF NOT EXISTS idx_aliments_type_alimentation ON aliments(type_alimentation)',\n            \n            # Index pour les scores de qualit√©\n            'idx_aliments_healthy': 'CREATE INDEX IF NOT EXISTS idx_aliments_healthy ON aliments(indice_healthy DESC)',\n            'idx_aliments_commun': 'CREATE INDEX IF NOT EXISTS idx_aliments_commun ON aliments(indice_commun DESC)',\n            \n            # Index compos√©s pour requ√™tes complexes (inspir√© de Cronometer)\n            'idx_aliments_cat_kcal': 'CREATE INDEX IF NOT EXISTS idx_aliments_cat_kcal ON aliments(categorie, kcal_100g)',\n            'idx_aliments_prot_healthy': 'CREATE INDEX IF NOT EXISTS idx_aliments_prot_healthy ON aliments(proteines_100g DESC, indice_healthy DESC)',\n            'idx_aliments_fibres_kcal': 'CREATE INDEX IF NOT EXISTS idx_aliments_fibres_kcal ON aliments(fibres_100g DESC, kcal_100g ASC)',\n            \n            # Index pour tri par densit√© nutritionnelle (calcul rapide)\n            'idx_aliments_densite_calc': '''CREATE INDEX IF NOT EXISTS idx_aliments_densite_calc ON aliments(\n                CASE WHEN kcal_100g > 0 THEN (proteines_100g * 4 + COALESCE(fibres_100g, 0) * 2) / kcal_100g ELSE 0 END DESC\n            )''',\n        }\n        \n        results = {}\n        with db_manager.get_connection() as conn:\n            for index_name, sql in indexes.items():\n                try:\n                    conn.execute(sql)\n                    results[index_name] = True\n                    print(f\"  ‚úì {index_name}\")\n                except Exception as e:\n                    results[index_name] = False\n                    print(f\"  ‚úó {index_name}: {str(e)}\")\n            \n            conn.commit()\n        \n        return results\n    \n    def _create_profils_indexes(self) -> Dict[str, bool]:\n        \"\"\"Cr√©e les index pour la table profils_nutritionnels\"\"\"\n        \n        print(\"üë§ Cr√©ation des index pour la table 'profils_nutritionnels'...\")\n        \n        # S'assurer que la table existe d'abord\n        with db_manager.get_connection() as conn:\n            conn.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS profils_nutritionnels (\n                    id INTEGER PRIMARY KEY,\n                    client_id INTEGER NOT NULL,\n                    age INTEGER NOT NULL,\n                    sexe TEXT NOT NULL,\n                    poids_kg REAL NOT NULL,\n                    taille_cm REAL NOT NULL,\n                    objectif_principal TEXT NOT NULL,\n                    niveau_activite TEXT NOT NULL,\n                    restrictions_alimentaires TEXT DEFAULT '[]',\n                    regimes_compatibles TEXT DEFAULT '[]',\n                    aliments_preferes TEXT DEFAULT '[]',\n                    aliments_exclus TEXT DEFAULT '[]',\n                    nombre_repas_souhaite INTEGER DEFAULT 3,\n                    metabolism_basal REAL,\n                    besoins_caloriques REAL,\n                    repartition_macros TEXT DEFAULT '{}',\n                    date_creation TEXT NOT NULL,\n                    date_mise_a_jour TEXT NOT NULL,\n                    FOREIGN KEY(client_id) REFERENCES clients(id),\n                    UNIQUE(client_id)\n                )\n                \"\"\"\n            )\n            conn.commit()\n        \n        indexes = {\n            # Index principal pour requ√™tes par client\n            'idx_profils_client_id': 'CREATE UNIQUE INDEX IF NOT EXISTS idx_profils_client_id ON profils_nutritionnels(client_id)',\n            \n            # Index pour filtres et analyses\n            'idx_profils_objectif': 'CREATE INDEX IF NOT EXISTS idx_profils_objectif ON profils_nutritionnels(objectif_principal)',\n            'idx_profils_age_sexe': 'CREATE INDEX IF NOT EXISTS idx_profils_age_sexe ON profils_nutritionnels(age, sexe)',\n            'idx_profils_besoins_cal': 'CREATE INDEX IF NOT EXISTS idx_profils_besoins_cal ON profils_nutritionnels(besoins_caloriques)',\n            \n            # Index pour analyses temporelles\n            'idx_profils_date_maj': 'CREATE INDEX IF NOT EXISTS idx_profils_date_maj ON profils_nutritionnels(date_mise_a_jour DESC)',\n        }\n        \n        results = {}\n        with db_manager.get_connection() as conn:\n            for index_name, sql in indexes.items():\n                try:\n                    conn.execute(sql)\n                    results[index_name] = True\n                    print(f\"  ‚úì {index_name}\")\n                except Exception as e:\n                    results[index_name] = False\n                    print(f\"  ‚úó {index_name}: {str(e)}\")\n            \n            conn.commit()\n        \n        return results\n    \n    def _create_plans_indexes(self) -> Dict[str, bool]:\n        \"\"\"Cr√©e les index pour les tables de plans alimentaires\"\"\"\n        \n        print(\"üçΩÔ∏è Cr√©ation des index pour les tables de plans alimentaires...\")\n        \n        indexes = {\n            # Plans alimentaires\n            'idx_plans_client_id': 'CREATE INDEX IF NOT EXISTS idx_plans_client_id ON plans_alimentaires(client_id)',\n            'idx_plans_tags': 'CREATE INDEX IF NOT EXISTS idx_plans_tags ON plans_alimentaires(tags)',\n            \n            # Repas\n            'idx_repas_plan_id': 'CREATE INDEX IF NOT EXISTS idx_repas_plan_id ON repas(plan_id)',\n            'idx_repas_plan_ordre': 'CREATE INDEX IF NOT EXISTS idx_repas_plan_ordre ON repas(plan_id, ordre)',\n            \n            # Items de repas (critique pour performance)\n            'idx_repas_items_repas_id': 'CREATE INDEX IF NOT EXISTS idx_repas_items_repas_id ON repas_items(repas_id)',\n            'idx_repas_items_aliment_id': 'CREATE INDEX IF NOT EXISTS idx_repas_items_aliment_id ON repas_items(aliment_id)',\n            'idx_repas_items_portion_id': 'CREATE INDEX IF NOT EXISTS idx_repas_items_portion_id ON repas_items(portion_id)',\n            \n            # Portions (optimisation recherche)\n            'idx_portions_aliment_id': 'CREATE INDEX IF NOT EXISTS idx_portions_aliment_id ON portions(aliment_id)',\n            'idx_portions_aliment_grammes': 'CREATE INDEX IF NOT EXISTS idx_portions_aliment_grammes ON portions(aliment_id, grammes_equivalents)',\n        }\n        \n        results = {}\n        with db_manager.get_connection() as conn:\n            for index_name, sql in indexes.items():\n                try:\n                    conn.execute(sql)\n                    results[index_name] = True\n                    print(f\"  ‚úì {index_name}\")\n                except Exception as e:\n                    results[index_name] = False\n                    print(f\"  ‚úó {index_name}: {str(e)}\")\n            \n            conn.commit()\n        \n        return results\n    \n    def _optimize_existing_indexes(self) -> Dict[str, any]:\n        \"\"\"Optimise les index existants\"\"\"\n        \n        print(\"üîß Optimisation des index existants...\")\n        \n        with db_manager.get_connection() as conn:\n            # Analyse et reconstruction si n√©cessaire\n            conn.execute(\"ANALYZE\")\n            \n            # Statistiques avant optimisation\n            stats_before = self._get_index_stats(conn)\n            \n            # Reconstruction des index fragment√©s (si SQLite le supportait)\n            # Pour SQLite, on utilisera VACUUM au lieu\n            conn.execute(\"VACUUM\")\n            \n            # Statistiques apr√®s optimisation\n            stats_after = self._get_index_stats(conn)\n        \n        return {\n            'stats_before': stats_before,\n            'stats_after': stats_after,\n            'vacuum_executed': True\n        }\n    \n    def _get_index_stats(self, conn: sqlite3.Connection) -> Dict[str, any]:\n        \"\"\"R√©cup√®re les statistiques des index\"\"\"\n        \n        # Liste tous les index\n        indexes = conn.execute(\n            \"SELECT name, tbl_name FROM sqlite_master WHERE type='index' AND name NOT LIKE 'sqlite_%'\"\n        ).fetchall()\n        \n        return {\n            'total_indexes': len(indexes),\n            'indexes_by_table': {}\n        }\n    \n    def _analyze_database_stats(self) -> Dict[str, any]:\n        \"\"\"Analyse les statistiques de la base de donn√©es\"\"\"\n        \n        print(\"üìà Analyse des statistiques de la base de donn√©es...\")\n        \n        with db_manager.get_connection() as conn:\n            stats = {}\n            \n            # Taille de la base\n            stats['database_size_pages'] = conn.execute(\"PRAGMA page_count\").fetchone()[0]\n            stats['page_size_bytes'] = conn.execute(\"PRAGMA page_size\").fetchone()[0]\n            stats['database_size_mb'] = round((stats['database_size_pages'] * stats['page_size_bytes']) / (1024*1024), 2)\n            \n            # Nombre d'enregistrements par table\n            tables = ['aliments', 'portions', 'plans_alimentaires', 'repas', 'repas_items']\n            for table in tables:\n                try:\n                    count = conn.execute(f\"SELECT COUNT(*) FROM {table}\").fetchone()[0]\n                    stats[f'{table}_count'] = count\n                except:\n                    stats[f'{table}_count'] = 0\n            \n            # Test de performance sur requ√™tes critiques\n            stats['performance_tests'] = self._run_performance_tests(conn)\n        \n        return stats\n    \n    def _run_performance_tests(self, conn: sqlite3.Connection) -> Dict[str, float]:\n        \"\"\"Ex√©cute des tests de performance sur les requ√™tes critiques\"\"\"\n        \n        tests = {}\n        \n        # Test 1: Recherche d'aliment par nom\n        start = time.time()\n        conn.execute(\"SELECT * FROM aliments WHERE nom LIKE '%poulet%' LIMIT 10\").fetchall()\n        tests['search_by_name_ms'] = round((time.time() - start) * 1000, 2)\n        \n        # Test 2: Recherche par cat√©gorie et calories\n        start = time.time()\n        conn.execute(\n            \"SELECT * FROM aliments WHERE categorie = 'Viandes' AND kcal_100g < 200 ORDER BY proteines_100g DESC LIMIT 20\"\n        ).fetchall()\n        tests['category_filter_ms'] = round((time.time() - start) * 1000, 2)\n        \n        # Test 3: Requ√™te complexe avec jointures\n        start = time.time()\n        conn.execute(\n            \"\"\"\n            SELECT a.nom, p.description, p.grammes_equivalents \n            FROM aliments a \n            JOIN portions p ON a.id = p.aliment_id \n            WHERE a.proteines_100g > 20 \n            LIMIT 50\n            \"\"\"\n        ).fetchall()\n        tests['join_query_ms'] = round((time.time() - start) * 1000, 2)\n        \n        return tests\n    \n    def _optimize_sqlite_settings(self) -> Dict[str, any]:\n        \"\"\"Optimise les param√®tres SQLite pour les performances\"\"\"\n        \n        print(\"‚öôÔ∏è Configuration des param√®tres SQLite...\")\n        \n        optimizations = {\n            # Cache plus important pour de meilleures performances\n            'PRAGMA cache_size = -64000',  # 64MB de cache\n            \n            # Mode journal pour les performances (attention √† la s√©curit√© en prod)\n            'PRAGMA journal_mode = WAL',\n            \n            # Synchronisation optimis√©e\n            'PRAGMA synchronous = NORMAL',\n            \n            # Optimisations de performance\n            'PRAGMA temp_store = MEMORY',\n            'PRAGMA mmap_size = 268435456',  # 256MB memory-mapped I/O\n            \n            # Analyse automatique pour maintenir les statistiques\n            'PRAGMA automatic_index = ON',\n        }\n        \n        results = {}\n        with db_manager.get_connection() as conn:\n            for pragma_name, pragma_sql in optimizations.items():\n                try:\n                    conn.execute(pragma_sql)\n                    results[pragma_name] = 'SUCCESS'\n                    print(f\"  ‚úì {pragma_name}\")\n                except Exception as e:\n                    results[pragma_name] = f'ERROR: {str(e)}'\n                    print(f\"  ‚úó {pragma_name}: {str(e)}\")\n        \n        return results\n    \n    def benchmark_critical_queries(self) -> Dict[str, float]:\n        \"\"\"Benchmark des requ√™tes critiques apr√®s optimisation\"\"\"\n        \n        print(\"üèÅ Benchmark des requ√™tes critiques...\")\n        \n        queries = {\n            'simple_name_search': {\n                'sql': \"SELECT * FROM aliments WHERE nom LIKE ? ORDER BY nom LIMIT 20\",\n                'params': ('%tomate%',)\n            },\n            'advanced_filter': {\n                'sql': \"\"\"\n                    SELECT * FROM aliments \n                    WHERE categorie = ? AND proteines_100g >= ? AND kcal_100g <= ?\n                    ORDER BY indice_healthy DESC, proteines_100g DESC \n                    LIMIT 30\n                \"\"\",\n                'params': ('Viandes', 15.0, 300.0)\n            },\n            'nutritional_ranking': {\n                'sql': \"\"\"\n                    SELECT *, \n                           CASE WHEN kcal_100g > 0 THEN (proteines_100g * 4 + COALESCE(fibres_100g, 0) * 2) / kcal_100g ELSE 0 END as densite\n                    FROM aliments \n                    ORDER BY densite DESC \n                    LIMIT 50\n                \"\"\",\n                'params': ()\n            },\n            'complementary_foods': {\n                'sql': \"\"\"\n                    SELECT a.*, \n                           ABS(a.proteines_100g - ?) + ABS(a.glucides_100g - ?) + ABS(a.lipides_100g - ?) as score\n                    FROM aliments a \n                    WHERE a.id != ? \n                    ORDER BY score ASC \n                    LIMIT 10\n                \"\"\",\n                'params': (25.0, 30.0, 15.0, 1)\n            }\n        }\n        \n        results = {}\n        \n        with db_manager.get_connection() as conn:\n            for query_name, query_info in queries.items():\n                # Mesure de performance (moyenne sur 3 ex√©cutions)\n                times = []\n                \n                for _ in range(3):\n                    start = time.time()\n                    conn.execute(query_info['sql'], query_info['params']).fetchall()\n                    times.append((time.time() - start) * 1000)\n                \n                avg_time = sum(times) / len(times)\n                results[query_name] = round(avg_time, 2)\n                \n                # V√©rification de l'objectif sub-200ms\n                status = \"‚úÖ\" if avg_time < 200 else \"‚ö†Ô∏è\" if avg_time < 500 else \"‚ùå\"\n                print(f\"  {status} {query_name}: {avg_time:.2f}ms\")\n        \n        return results\n    \n    def create_full_text_search_virtual_table(self) -> bool:\n        \"\"\"Cr√©e une table virtuelle FTS pour la recherche textuelle avanc√©e\"\"\"\n        \n        print(\"üîç Cr√©ation de la table FTS pour recherche avanc√©e...\")\n        \n        try:\n            with db_manager.get_connection() as conn:\n                # Cr√©ation de la table FTS\n                conn.execute(\n                    \"\"\"\n                    CREATE VIRTUAL TABLE IF NOT EXISTS aliments_fts USING fts5(\n                        nom, \n                        categorie, \n                        content='aliments', \n                        content_rowid='id'\n                    )\n                    \"\"\"\n                )\n                \n                # Population de la table FTS\n                conn.execute(\n                    \"\"\"\n                    INSERT INTO aliments_fts(aliments_fts) VALUES('rebuild')\n                    \"\"\"\n                )\n                \n                conn.commit()\n                print(\"  ‚úÖ Table FTS cr√©√©e et popul√©e\")\n                return True\n                \n        except Exception as e:\n            print(f\"  ‚ùå Erreur FTS: {str(e)}\")\n            return False\n    \n    def generate_optimization_report(self, results: Dict[str, any]) -> str:\n        \"\"\"G√©n√®re un rapport d'optimisation\"\"\"\n        \n        report = []\n        report.append(\"=\" * 60)\n        report.append(\"üìä RAPPORT D'OPTIMISATION DE LA BASE DE DONN√âES\")\n        report.append(\"=\" * 60)\n        report.append(\"\")\n        \n        # R√©sum√© des performances\n        if 'statistics' in results and 'performance_tests' in results['statistics']:\n            perf = results['statistics']['performance_tests']\n            report.append(\"üèÅ PERFORMANCES DES REQU√äTES CRITIQUES:\")\n            for test, time_ms in perf.items():\n                status = \"‚úÖ\" if time_ms < 200 else \"‚ö†Ô∏è\" if time_ms < 500 else \"‚ùå\"\n                report.append(f\"  {status} {test}: {time_ms}ms\")\n            report.append(\"\")\n        \n        # Statistiques de la base\n        if 'statistics' in results:\n            stats = results['statistics']\n            report.append(\"üìà STATISTIQUES DE LA BASE:\")\n            report.append(f\"  üìè Taille: {stats.get('database_size_mb', 'N/A')} MB\")\n            report.append(f\"  üçé Aliments: {stats.get('aliments_count', 'N/A')}\")\n            report.append(f\"  üìè Portions: {stats.get('portions_count', 'N/A')}\")\n            report.append(\"\")\n        \n        # Index cr√©√©s\n        total_indexes = 0\n        for category, indexes in results.items():\n            if isinstance(indexes, dict) and 'indexes' in category:\n                successful = sum(1 for success in indexes.values() if success)\n                total = len(indexes)\n                report.append(f\"üìä {category.upper()}: {successful}/{total} index cr√©√©s\")\n                total_indexes += successful\n        \n        report.append(f\"\\nüéØ TOTAL: {total_indexes} index optimis√©s\")\n        report.append(f\"‚è±Ô∏è Temps total: {results.get('total_optimization_time', 'N/A')}s\")\n        report.append(\"\")\n        \n        # Recommandations\n        report.append(\"üí° RECOMMANDATIONS:\")\n        report.append(\"  ‚Ä¢ Ex√©cuter ANALYZE p√©riodiquement\")\n        report.append(\"  ‚Ä¢ Surveiller la croissance de la base\")\n        report.append(\"  ‚Ä¢ Consid√©rer la compression pour les gros volumes\")\n        report.append(\"  ‚Ä¢ Tester les performances apr√®s ajout de donn√©es\")\n        \n        return \"\\n\".join(report)\n\n\ndef optimize_database_for_nutrition():\n    \"\"\"Point d'entr√©e principal pour l'optimisation\"\"\"\n    \n    optimizer = DatabaseOptimizer()\n    \n    # Optimisation compl√®te\n    results = optimizer.optimize_full_database()\n    \n    # Table FTS pour recherche avanc√©e\n    fts_success = optimizer.create_full_text_search_virtual_table()\n    results['fts_created'] = fts_success\n    \n    # Benchmark final\n    benchmark_results = optimizer.benchmark_critical_queries()\n    results['final_benchmark'] = benchmark_results\n    \n    # G√©n√©ration du rapport\n    report = optimizer.generate_optimization_report(results)\n    print(\"\\n\" + report)\n    \n    # Sauvegarde du rapport\n    try:\n        with open('database_optimization_report.txt', 'w', encoding='utf-8') as f:\n            f.write(report)\n        print(\"\\nüìÑ Rapport sauvegard√©: database_optimization_report.txt\")\n    except Exception as e:\n        print(f\"\\n‚ö†Ô∏è Impossible de sauvegarder le rapport: {e}\")\n    \n    return results\n\n\nif __name__ == \"__main__\":\n    optimize_database_for_nutrition()